-- Seems to need a little debuging
module Collision where

import Graphics.Gloss
import Space
import Object
import           Prelude        hiding (lines)

--This comment is to make a commit for the new  branch.

collides :: Space -> LocalObj -> LocalObj -> Bool --assumes space reduced objects
collides space r1 r2 = or [simpleCollides (place x) (place y) | x <- (dups space r1) , y <- (dups space r2) ]

simpleCollides :: Object -> Object -> Bool
simpleCollides object1 object2 = or [partCollision part1 part2 | part1 <- object1, part2 <- object2 ]
 where
  -- You could make color dependent collision if you want
  partCollision (s1,_) (s2,_) = shapeCollision s1 s2

    where
      --3 pixels of forgiveness
      shapeCollision (Circ (point1, radius1)) (Circ (point2, radius2)) =  (norm point1 point2) < (radius1 + radius2) - 3

      --if either polygon contains points of the other inside it
      shapeCollision polygon1@(Pol points1) polygon2@(Pol points2) = or $ map (contains polygon1) points2 ++ map (contains polygon2) points1

      shapeCollision s@(Circ (c,r)) p@(Pol pts) = or $ [contains p c]++[circleHasLine s l | l <- lines p]
        where
          --generates the possible lines that come from the shape
          lines:: Shape -> [(Point,Point)]
          lines (Pol xs@(x:_)) = doubles xs x
            where
              doubles [] _ = error "expected nonempty list"
              doubles (a:[]) f    = [(a,f)]
              doubles (a:b:cs) f = (a,b) : doubles (b:cs) f


      shapeCollision polygon@(Pol _) circle@(Circ _) = shapeCollision circle polygon

      --does a line, generated by the two points, pass through the circle?
      circleHasLine :: Shape -> (Point, Point) -> Bool
      circleHasLine (Circ (c,r)) (p1,p2) = ((min d2 (c `norm` p2)) < r) || and [ (h-3 < r), b>0, b < v1FromOrigin]
        where
          v1 = p2 *- p1 :: Point
          v1FromOrigin = (0,0) `norm` v1 :: Float
          v2 = c *- p1 ::Point
          v2FromOrigin = (0,0) `norm` v2 :: Float

          dot = v1 `ptDot` v2 :: Float

          b = dot/v1FromOrigin :: Float
          h = sqrt $ v2FromOrigin^2 - b^2 :: Float

      circleHasLine _ _ = error "circleHasLine expects a circle"


      norm :: Point -> Point -> Float
      norm (x1,y1) (x2,y2) = sqrt $ (x1-x2)^2 + (y1-y2)^2


isCirc :: Shape -> Bool
isCirc (Circ _) = True
isCirc (Pol _)  = False





contains :: Shape -> Point -> Bool
contains (Circ (center, radius)) point = norm center point < r
contains q@(Pol _) p = odd $ length $ filter id [triangleHas tri p | tri <- (triangulate q)]

  where

    mkTriangles :: Shape -> [Shape]
    mkTriangles (Circ _) = error "You can only triangulate polygons"
    mkTriangles (Pol (x1:x2:[])) = []
    mkTriangles (Pol (x1:x2:x3:xs)) = (Pol [x1,x2,x3]) : mkTriangles (Pol (x1:x3:xs))


triangleHas::Shape->Point->Bool
triangleHas (Pol ((x1,y1):(x2,y2):(x3,y3):[])) (x,y) = and [s>0,t>0,t+s<1]
  where
    s = 1/(2*a)*(y1*x3 - x1*y3 + (y3 - y1)*x + (x1 - x3)*y)
    t = 1/(2*a)*(x1*y2 - y1*x2 + (y1 - y2)*x + (x2 - x1)*y)
    a = 0.5 *(-y2*x3 + y1*(-x2 + x3) + x1*(y2 - y3) + x2*y3)
triangleHas _ _ = error "triangleHas is only for triangles"



(*-)::Point->Point->Point
(x1,y1) *- (x2,y2) = (x1-x2,y1-y2)

ptDot::Point -> Point -> Float
ptDot (x1,y1) (x2,y2) = x1*x2+y1*y2
